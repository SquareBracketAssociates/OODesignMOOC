{
    "title":"Turning Procedure to Objects",
    "subtitle":"",
    "author":"StÃ©phane Ducasse"
}

${slide:title=Objects are powerful}$

- Super basic to say it but ""Objects are powerful""
- Example with ==Behavior>>printHierarchy== vs. ==ClassHierarchyPrinter==
-- ==printHierarchy== is a method
-- ==ClassHierarchyPrinter== is a little class

${slide:title=Functionality Example}$

[[[
Rectangle printHierarchy
>>> 
ProtoObject #()
	Object #()

		Rectangle #(#origin #corner)
			CharacterBlock #(#stringIndex #text #textLine)'
]]]


${slide:title=Coded as...}$

[[[
Behavior >> printHierarchy
	"Answer a description containing the names and instance variable names 
	of all of the subclasses and superclasses of the receiver."

	| aStream index |
	index := 0.
	aStream := (String new: 16) writeStream.
	self allSuperclasses reverseDo: 
		[:aClass | 
		aStream crtab: index.
		index := index + 1.
		aStream nextPutAll: aClass name.
		aStream space.
		aStream print: aClass instVarNames].
	aStream cr.
	self printSubclassesOn: aStream level: index.
	^aStream contents
]]]

${slide:title=With...}$
[[[
ClassDescription >> printSubclassesOn: aStream level: level 
		"As part of the algorithm for printing a description of the receiver, print the
		subclass on the file stream, aStream, indenting level times."

		| subclassNames |
		aStream crtab: level.
		aStream nextPutAll: self name.
		aStream space; print: self instVarNames.
		self == Class
			ifTrue: 
				[aStream crtab: level + 1; nextPutAll: '[ ... all the Metaclasses ... ]'.
				^self].
		subclassNames := self subclasses asSortedCollection:[:c1 :c2| c1 name <= c2 name].
		"Print subclasses in alphabetical order"
		subclassNames do:
			[:subclass | subclass printSubclassesOn: aStream level: level + 1]

]]]

${slide:title=Analysis}$

Pro
- Procedural decomposition
- Simple 
- State is passed as arguments

Cons: What if we need 
- to filter subclasses (==RBLintRule printHierarchy==)
- to cut above a given superclass
- do not want to see instance variables

We do want or cannot add state the domain. 
- Here we do not want to add state to ==Behavior== just for printing 


${slide:title=Turning it into an object}$

[[[
ClassHierarchyPrinter new  
	forClass: Rectangle; 
	doNotShowState;
	doNotShowSuperclasses
]]]

${slide:title=More complex scenario}$

[[[
ClassHierarchyPrinter new 
	forClass: RBNode; 
	doNotShowState;
	doNotShowSuperclasses;
	excludedClasses: (RBNode withAllSubclasses 
						select: [ :each | each name beginsWith: RBPattern ]);
	limitedToClasses: (RBNode withAllSubclasses 
							select: [:each | each name beginsWith: RB]).
]]]

${slide:title=Looking at ClassHierarchyPrinter}$

[[[
Object << #ClassHierarchyPrinter
	slots: { #theClass . #excludedClasses . #limitedToClasses . #stream . 
	#level . #showSuperclasses . #showState };
	tag: 'ForPharo';
	package: 'Kernel-ExtraUtils'
]]]


API
- ==doNotShowState==, ==doNotShowSuperclasses==
- ==limitedToClasses:== to offer specific scope
- ==excludedClasses:== to remove unwanted subclasses
- ==cr==, ==tab==, ==nextPutAll:== to let decorations



${slide:title=Further thought}$

- If the functionality needs to behave differently on different objects (Classes, Traits, Metaclasses...) we can use double dispatch between the objects that the printers as it is done in the ==ClassDefinitionPrinter==

