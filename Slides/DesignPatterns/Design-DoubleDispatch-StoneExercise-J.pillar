{
    "title" : "Stone Paper Scissors - J version",
    "slidesid" : "From the Design Corner",
    "author" : "StÃ©phane Ducasse"
}


${slide:title=Let us start with a test}$

[[[
@Test
	public void testStoneVsStone() {
		assertEquals(new Stone().play(new Stone()),0);
		}
]]]


${slide:title=Stone...}$
[[[
class Stone {
	public int play (Stone h){
		return ...
	}
}
]]]


${slide:title=Stone...}$
[[[
class Stone {
	public int play (Stone h){
		return h.playAgainstStone(this);
	}
}
]]]


${slide:title=Stone...}$
[[[
class Stone {
	public int play (Stone h){
		return h.playAgainstStone(this);
	}
	public int playAgainstStone(Stone s){
		return ...
	}
}
]]]

${slide:title=Stone...}$
[[[
class Stone {
	public int play (Stone h){
		return h.playAgainstStone(this);
	}
	public int playAgainstStone(Stone s){
		return 0;
	}
}
]]]

${slide:title=Another test...}$
[[[
@Test
	public void testStoneVsPaper() {
		assertEquals(new Stone().play(new Paper()),-1);
		}
]]]

${slide:title=Paper...}$
[[[
class Paper {
	public int playAgainstStone(Paper s){
		return 0;
	}
}
]]]

${slide:title=Well this is Java, adding an interface}$

[[[
interface IHand {
    int play (IHand h);
    int playAgainstStone (Stone s);
    int playAgainstScissor (Scissor s);
    int playAgainstPaper (Paper p);
 }
]]]





${slide:title=Full Solution: Stone}$
[[[
class Stone implements IHand {
    public int play (IHand h){
        return h.playAgainstStone(this);
    }
    public int playAgainstStone(Stone s){ return 0;}
    public int playAgainstScissor(Scissor s){ return 1;}
    public int playAgainstPaper(Paper s){ return -1;}
}
]]]

${slide:title=Full Solution: Scissor}$
[[[
class Scissor implements IHand {
    public int play (IHand h){
        return h.playAgainstScissor(this);
    }
    public int playAgainstStone(Stone s){ return -1;}
    public int playAgainstScissor(Scissor s){ return 0;}
    public int playAgainstPaper(Paper s){ return 1;
    }
}
]]]

${slide:title=Full Solution: Paper}$
[[[
class Paper implements IHand {
    public int play (IHand h){
        return h.playAgainstPaper(this);}
    public int playAgainstStone(Stone s){ return 1;}
    public int playAgainstScissor(Scissor s){ return -1;}
    public int playAgainstPaper(Paper s){ return 0;
    }
}
]]]

${slide:title=Let us start}$

[[[
StonePaperScissorsTest >> testPaperIsWinning
	self assert: (Stone new play: Paper new) = #paper
]]]

[[[
Stone >> play: anotherTool
	^ ...
]]]


${slide:title= Paper playAgainstStone: }$

[[[
StonePaperScissorsTest >> testPaperIsWinning
	self assert: (Stone new play: Paper new) = #paper
]]]

[[[
Stone >> play: anotherTool
	^ anotherTool playAgainstStone: self
]]]

[[[
Paper >> playAgainstStone: aStone
	^ #paper
]]]


${slide:title=Other playAgainstStone: }$

[[[
Scissors >> playAgainstStone: aStone
	^ #stone
]]]

[[[
Stone >> playAgainstStone: aStone
	^ #draw
]]]


${slide:title=Scissors now }$

[[[
StonePaperScissorsTest >> testScissorsIsWinning
	self assert: (Scissors new play: Paper new) = #scissors
]]]

[[[
Scissors >> play: anotherTool
	^ anotherTool playAgainstScissors: self
]]]

[[[
Scissors >> playAganstScissors: aScissors
	^ #draw
]]]

[[[
Paper >> playAgainstScissors: aScissors
	^ #scissors
]]]

[[[
Stone >> playAgainstScissors: aScissors
	^ #stone
]]]

${slide:title=Paper now }$
[[[
Paper >> play: anotherTool
	^ anotherTool playAgainstPaper: self
]]]

[[[
Scissors >> playAgainstPaper: aPaper
	^ #scissors
]]]

[[[
Paper >> playAgainstPaper: aPaper
	^ #draw
]]]

[[[
Stone >> playAgainstPaper: aPaper
	^ #paper
]]]

${slide:title=Overview}$

+An overview of a possible solution using double dispatch.>file://figures/StonePaperScissors.pdf|width=80+

${slide:title=Remark}$

In this example we do not need to pass the argument during the double dispatch

[[[
Scissors >> playAgainstPaper: aPaper
	^ #scissors
]]]

[[[
Scissors >> playAgainstPaper
	^ #scissors
]]]

${slide:title=Thinking more...}$

When we return a token or a number we should check to do something after.
So passing blocks may be better.

[[[
Paper new competeWith: Paper new
	onDraw: [ Game incrementDraw ]
	onReceiverWin: [ ]
	onReceiverLose: [ ]
]]]

${slide:title=Conclusion}$

- Powerful
- Modular
- Just sending an extra message to an argument and using late binding
