{
    "title":"Polymorphism at work",
    "subtitle":"",
    "author":"StÃ©phane Ducasse"
}

${slide:title=A little exercise}$

[[[
testBasic 

	self assert: #((1 2) (3) 4) flatten equals: #(1 2 3 4).
	self assert: #(((1 2) 5) (3) 4) flatten equals: #(1 2 5 3 4).
]]]

[[[
testBasicEliminatingNil

	self assert: #((1 nil 2) nil (3) 4) flatten equals: #(1 2 3 4).
	self assert: #(((1 nil 2)) nil (3) 4) flatten equals: #(1 2 3 4).
	self assert: #(nil) flatten equals: #()
]]]

${slide:title=A first "solution"}$

[[[
Object >> flattenArray: aCollection
	^ (OrderedCollection
		streamContents: [ :stream | self flatten: aCollection into: stream ]) asArray
]]]

[[[
Object >> flatten: anObject into: result
	^ anObject isCollection
		ifTrue: [ anObject do: [ :item | self flatten: item into: result ] ]
		ifFalse: [ anObject ifNotNil: [ result nextPut: anObject ] ]
]]]


${slide:title=Analysis}$

Why do we have all these tests?



${slide:title=A much nicer solution}$

[[[
Object >> flatten
	^ (OrderedCollection 
		streamContents: [ :stream | self flattenInto: stream ]) asArray
]]]

[[[
Object >> flattenInto: result
	result nextPut: self
]]]

[[[
Collection >> flattenInto: result
	self do: [ :item | item flattenInto: result ]
]]]

	
To handle nil
[[[
UndefinedObject >> flattenInto: result
	^ self
]]]

${slide:title=Remember}$

- Sending a message is making a choice
- We have three version of ==flattenInto:==.
- Late binding at execution pick the right one. 